/*
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013 by Adam Kurkiewicz
 * You can contact me by e-mail at: adam /at\ kurkiewicz /dot\ pl
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software. 
 */

import java.util.ArrayList;
import java.util.concurrent.ConcurrentLinkedQueue;


public class TarjansGraph extends AbstractGraph<TarjansNode>{
	ArrayList<TarjansNode> nodes = new ArrayList<>();
	
	public TarjansGraph(){};
	public TarjansGraph(ArrayList<TarjansNode> nodes){
		this.nodes = nodes;
	}
	
	@Override
	public void addNode(TarjansNode node) {
		node.setGraph(this);
		this.nodes.add(node);
	}

	@Override
	public ConcurrentLinkedQueue<NonBlockingHashMap<Long, TarjansNode>> getSolutions() {
		return TarjansAlgo(nodes);
	}

	@Override
	public void reportSolution(NonBlockingHashMap<Long, TarjansNode> solution) {
	}
	
	// Methods needed for Tarjans Algo:
	
	public ConcurrentLinkedQueue<NonBlockingHashMap<Long, TarjansNode>>
			order(ArrayList<TarjansNode> nodes){
		ConcurrentLinkedQueue<NonBlockingHashMap<Long, TarjansNode>> sorted = new ConcurrentLinkedQueue<NonBlockingHashMap<Long, TarjansNode>>();
		NonBlockingHashMap<Long, TarjansNode> sccGroup = new NonBlockingHashMap<Long, TarjansNode>();
		while(nodes.size()!=0){
			sccGroup.put(nodes.get(0).getID(), nodes.get(0));
			for(TarjansNode node: nodes){
				if(sccGroup.contains(node)){ sccGroup.put(node.getID(), node); nodes.remove(node);}
			}
			sorted.add(sccGroup);
			sccGroup.clear();
		}
		return sorted;
	}
	
	/** LOWLINK: the smallest vertex which is in the same component as startNode
	* and is reachable by traversing zero or more tree arcs followed by at most one 
	* front or cross-link
	* Stack is generated by dfs.  
	*/
	public NonBlockingHashMap<Long, TarjansNode>
			LOWLINK(TarjansNode startNode, ArrayList<TarjansNode> stack){
		TarjansNode lowLink = startNode;
		for(TarjansNode node:stack){
			if(node.getID()<lowLink.getID()){ lowLink = node; }
		}
		NonBlockingHashMap<Long, TarjansNode> result = new NonBlockingHashMap<Long, TarjansNode>();
		result.put(lowLink.getID(), startNode);
		return result;
	}
	
	// DFS for one direction;
	public ArrayList<TarjansNode> DFS(TarjansNode startNode, ArrayList<TarjansNode> nodes){
		//TODO: not finished, dfs only for one direction
		ArrayList<TarjansNode> stack = new ArrayList<>();
		stack.add(startNode);
		TarjansNode child= new TarjansNode();
		int stackIndex = stack.size()-1;
		boolean stop = false;
		
		while(nodes.size()!=0){
			child = startNode.getChild();			
			while(child.doesChildExist()){
				startNode.visit = true;
				nodes.remove(startNode);
				child = startNode.getChild();
				stack.add(child);
				startNode = child;
			}
			// search for unvisited child of a node in the stack
			// if we find one: stop the loop
			// if we don't find any(stop is false): exit and return the stack
			while((stackIndex!=0)||(!stop)){
				startNode = stack.get(stackIndex);
				if(!startNode.allChildrenVisited(startNode)){stop = true;}
				stackIndex --;
			}
			if(stop){break;}
		}
		return stack;
	}
	
	public ConcurrentLinkedQueue<NonBlockingHashMap<Long, TarjansNode>>
			TarjansAlgo(ArrayList<TarjansNode> nodes){
		ArrayList<TarjansNode> lowlinks = new ArrayList<>();
		for(TarjansNode node: nodes){
			LOWLINK(node, DFS(node, nodes));
			lowlinks.add((TarjansNode) LOWLINK(node, DFS(node, nodes)).values());
		}		
		return order(lowlinks);
	}
}
